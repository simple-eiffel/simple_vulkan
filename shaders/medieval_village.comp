#version 450

/*
 * Medieval Village Demo - GPU SDF Ray Marching
 *
 * A procedural medieval European village scene featuring:
 * - Half-timbered houses with pitched roofs
 * - Stone church with steeple
 * - Watchtower
 * - Village well
 * - Trees
 * - Cobblestone ground
 * - Perimeter wall
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, binding = 0) buffer OutputBuffer {
    uint pixels[];
};

layout(std430, binding = 1) buffer CameraParams {
    float cam_x;
    float cam_y;
    float cam_z;
    float cam_yaw;
    float cam_pitch;
    float time;
    uint width;
    uint height;
};

/* Ray marching parameters */
const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float SURF_DIST = 0.001;
const float PI = 3.14159265359;

/* ============================================================================
 * SDF Primitives
 * ============================================================================ */

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdPlane(vec3 p, vec3 n, float h) {
    return dot(p, n) + h;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdCappedCone(vec3 p, float h, float r1, float r2) {
    vec2 q = vec2(length(p.xz), p.y);
    vec2 k1 = vec2(r2, h);
    vec2 k2 = vec2(r2 - r1, 2.0 * h);
    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);
    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);
    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));
}

float sdTriPrism(vec3 p, vec2 h) {
    vec3 q = abs(p);
    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdRoundBox(vec3 p, vec3 b, float r) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

/* ============================================================================
 * Boolean Operations
 * ============================================================================ */

float opUnion(float d1, float d2) {
    return min(d1, d2);
}

float opSubtraction(float d1, float d2) {
    return max(-d1, d2);
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

/* ============================================================================
 * Building Components
 * ============================================================================ */

/* Half-timbered house with pitched roof */
float sdHouse(vec3 p, vec3 size, float roofHeight) {
    /* Main body */
    float body = sdBox(p - vec3(0, size.y, 0), size);

    /* Pitched roof - triangular prism */
    vec3 roofPos = p - vec3(0, size.y * 2.0 + roofHeight * 0.4, 0);
    roofPos.xz = roofPos.zx; /* Rotate roof orientation */
    float roof = sdTriPrism(roofPos, vec2(roofHeight, size.x * 1.1));

    return opUnion(body, roof);
}

/* Stone church with steeple */
float sdChurch(vec3 p) {
    /* Main nave */
    float nave = sdBox(p - vec3(0, 2.5, 0), vec3(3.0, 2.5, 6.0));

    /* Nave roof */
    vec3 naveRoofPos = p - vec3(0, 6.0, 0);
    float naveRoof = sdTriPrism(naveRoofPos, vec2(2.5, 6.2));

    /* Tower base */
    float tower = sdBox(p - vec3(0, 5.0, -5.0), vec3(1.5, 5.0, 1.5));

    /* Steeple (cone) */
    vec3 steeplePos = p - vec3(0, 13.0, -5.0);
    float steeple = sdCappedCone(steeplePos, 3.0, 1.8, 0.1);

    float church = opUnion(nave, naveRoof);
    church = opUnion(church, tower);
    church = opUnion(church, steeple);

    return church;
}

/* Watchtower */
float sdTower(vec3 p) {
    /* Main cylindrical tower */
    float tower = sdCylinder(p - vec3(0, 6.0, 0), 6.0, 2.5);

    /* Crenellations (simplified as ring) */
    float ring = sdTorus(p - vec3(0, 12.5, 0), vec2(2.5, 0.5));
    float ringCut = sdBox(p - vec3(0, 12.5, 0), vec3(2.0, 0.6, 2.0));
    ring = opSubtraction(ringCut, ring);

    /* Conical roof */
    vec3 roofPos = p - vec3(0, 14.5, 0);
    float roof = sdCappedCone(roofPos, 2.0, 3.0, 0.3);

    return opUnion(opUnion(tower, ring), roof);
}

/* Village well */
float sdWell(vec3 p) {
    /* Stone base (hollow cylinder) */
    float outer = sdCylinder(p - vec3(0, 0.5, 0), 0.5, 1.0);
    float inner = sdCylinder(p - vec3(0, 0.6, 0), 0.6, 0.8);
    float base = opSubtraction(inner, outer);

    /* Roof supports */
    float post1 = sdBox(p - vec3(0.9, 1.5, 0), vec3(0.1, 1.0, 0.1));
    float post2 = sdBox(p - vec3(-0.9, 1.5, 0), vec3(0.1, 1.0, 0.1));

    /* Roof */
    vec3 roofPos = p - vec3(0, 3.0, 0);
    roofPos.xz = roofPos.zx;
    float roof = sdTriPrism(roofPos, vec2(0.8, 1.2));

    float well = opUnion(base, post1);
    well = opUnion(well, post2);
    well = opUnion(well, roof);

    return well;
}

/* Tree (stylized) */
float sdTree(vec3 p, float height, float radius) {
    /* Trunk */
    float trunk = sdCylinder(p - vec3(0, height * 0.3, 0), height * 0.3, radius * 0.15);

    /* Foliage layers (stacked cones) */
    vec3 f1Pos = p - vec3(0, height * 0.6, 0);
    float foliage1 = sdCappedCone(f1Pos, height * 0.35, radius, radius * 0.1);

    vec3 f2Pos = p - vec3(0, height * 0.85, 0);
    float foliage2 = sdCappedCone(f2Pos, height * 0.25, radius * 0.7, radius * 0.05);

    return opUnion(trunk, opUnion(foliage1, foliage2));
}

/* Wall section */
float sdWallSection(vec3 p, float length) {
    float wall = sdBox(p - vec3(0, 1.5, 0), vec3(length * 0.5, 1.5, 0.4));
    return wall;
}

/* ============================================================================
 * Scene Definition - Medieval Village
 * ============================================================================ */

/* Material IDs */
int g_matId = 0;
const int MAT_GROUND = 0;
const int MAT_HOUSE_WALL = 1;
const int MAT_ROOF = 2;
const int MAT_STONE = 3;
const int MAT_WOOD = 4;
const int MAT_FOLIAGE = 5;

float sceneSDF(vec3 p) {
    /* Ground plane */
    float ground = sdPlane(p, vec3(0.0, 1.0, 0.0), 0.0);
    float scene = ground;
    g_matId = MAT_GROUND;

    /* === HOUSES === */

    /* House 1 - front left */
    vec3 h1Pos = p - vec3(-8.0, 0.0, 5.0);
    float house1 = sdHouse(h1Pos, vec3(2.0, 1.5, 2.5), 1.5);
    if (house1 < scene) { scene = house1; g_matId = MAT_HOUSE_WALL; }

    /* House 2 - front right */
    vec3 h2Pos = p - vec3(8.0, 0.0, 6.0);
    h2Pos.xz = mat2(0.9, 0.4, -0.4, 0.9) * h2Pos.xz; /* Slight rotation */
    float house2 = sdHouse(h2Pos, vec3(2.5, 1.8, 2.0), 1.8);
    if (house2 < scene) { scene = house2; g_matId = MAT_HOUSE_WALL; }

    /* House 3 - back left */
    vec3 h3Pos = p - vec3(-10.0, 0.0, -8.0);
    float house3 = sdHouse(h3Pos, vec3(1.8, 1.4, 2.2), 1.3);
    if (house3 < scene) { scene = house3; g_matId = MAT_HOUSE_WALL; }

    /* House 4 - back right */
    vec3 h4Pos = p - vec3(6.0, 0.0, -10.0);
    h4Pos.xz = mat2(0.8, -0.6, 0.6, 0.8) * h4Pos.xz;
    float house4 = sdHouse(h4Pos, vec3(2.2, 1.6, 2.8), 1.6);
    if (house4 < scene) { scene = house4; g_matId = MAT_HOUSE_WALL; }

    /* House 5 - small cottage */
    vec3 h5Pos = p - vec3(-4.0, 0.0, -6.0);
    float house5 = sdHouse(h5Pos, vec3(1.5, 1.2, 1.8), 1.0);
    if (house5 < scene) { scene = house5; g_matId = MAT_HOUSE_WALL; }

    /* === CHURCH === */
    vec3 churchPos = p - vec3(0.0, 0.0, -18.0);
    float church = sdChurch(churchPos);
    if (church < scene) { scene = church; g_matId = MAT_STONE; }

    /* === WATCHTOWER === */
    vec3 towerPos = p - vec3(-18.0, 0.0, -15.0);
    float tower = sdTower(towerPos);
    if (tower < scene) { scene = tower; g_matId = MAT_STONE; }

    /* === VILLAGE WELL (center) === */
    vec3 wellPos = p - vec3(0.0, 0.0, 0.0);
    float well = sdWell(wellPos);
    if (well < scene) { scene = well; g_matId = MAT_STONE; }

    /* === TREES === */

    /* Tree cluster near houses */
    vec3 t1Pos = p - vec3(-14.0, 0.0, 2.0);
    float tree1 = sdTree(t1Pos, 4.0, 1.5);
    if (tree1 < scene) { scene = tree1; g_matId = MAT_FOLIAGE; }

    vec3 t2Pos = p - vec3(-15.5, 0.0, -2.0);
    float tree2 = sdTree(t2Pos, 5.0, 1.8);
    if (tree2 < scene) { scene = tree2; g_matId = MAT_FOLIAGE; }

    vec3 t3Pos = p - vec3(14.0, 0.0, 0.0);
    float tree3 = sdTree(t3Pos, 4.5, 1.6);
    if (tree3 < scene) { scene = tree3; g_matId = MAT_FOLIAGE; }

    vec3 t4Pos = p - vec3(12.0, 0.0, -5.0);
    float tree4 = sdTree(t4Pos, 3.5, 1.3);
    if (tree4 < scene) { scene = tree4; g_matId = MAT_FOLIAGE; }

    vec3 t5Pos = p - vec3(5.0, 0.0, 12.0);
    float tree5 = sdTree(t5Pos, 4.8, 1.7);
    if (tree5 < scene) { scene = tree5; g_matId = MAT_FOLIAGE; }

    /* === PERIMETER WALL === */

    /* Front wall with gap for entrance */
    vec3 fw1Pos = p - vec3(-12.0, 0.0, 15.0);
    float frontWall1 = sdWallSection(fw1Pos, 10.0);
    if (frontWall1 < scene) { scene = frontWall1; g_matId = MAT_STONE; }

    vec3 fw2Pos = p - vec3(12.0, 0.0, 15.0);
    float frontWall2 = sdWallSection(fw2Pos, 10.0);
    if (frontWall2 < scene) { scene = frontWall2; g_matId = MAT_STONE; }

    /* Side walls */
    vec3 swlPos = p - vec3(-20.0, 0.0, 0.0);
    swlPos.xz = swlPos.zx;
    float sideWallL = sdWallSection(swlPos, 30.0);
    if (sideWallL < scene) { scene = sideWallL; g_matId = MAT_STONE; }

    vec3 swrPos = p - vec3(20.0, 0.0, 0.0);
    swrPos.xz = swrPos.zx;
    float sideWallR = sdWallSection(swrPos, 30.0);
    if (sideWallR < scene) { scene = sideWallR; g_matId = MAT_STONE; }

    /* Back wall */
    vec3 bwPos = p - vec3(0.0, 0.0, -25.0);
    float backWall = sdWallSection(bwPos, 40.0);
    if (backWall < scene) { scene = backWall; g_matId = MAT_STONE; }

    return scene;
}

/* ============================================================================
 * Rendering
 * ============================================================================ */

vec3 calcNormal(vec3 p) {
    const float eps = 0.001;
    vec2 e = vec2(1.0, -1.0) * 0.5773 * eps;
    return normalize(
        e.xyy * sceneSDF(p + e.xyy) +
        e.yyx * sceneSDF(p + e.yyx) +
        e.yxy * sceneSDF(p + e.yxy) +
        e.xxx * sceneSDF(p + e.xxx)
    );
}

float rayMarch(vec3 ro, vec3 rd) {
    float depth = 0.0;

    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * depth;
        float d = sceneSDF(p);

        if (d < SURF_DIST) break;
        if (depth > MAX_DIST) break;

        depth += d;
    }

    return depth;
}

/* Soft shadow */
float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float t = mint;
    for (int i = 0; i < 32; i++) {
        float h = sceneSDF(ro + rd * t);
        res = min(res, k * h / t);
        t += clamp(h, 0.02, 0.5);
        if (h < 0.001 || t > maxt) break;
    }
    return clamp(res, 0.0, 1.0);
}

/* Ambient occlusion */
float calcAO(vec3 pos, vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    for (int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i);
        float d = sceneSDF(pos + h * nor);
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

vec3 getMaterialColor(int matId, vec3 p) {
    if (matId == MAT_GROUND) {
        /* Cobblestone pattern */
        vec2 uv = p.xz * 0.5;
        float pattern = sin(uv.x * 3.0) * sin(uv.y * 3.0);
        pattern = smoothstep(-0.2, 0.2, pattern);
        vec3 stone1 = vec3(0.35, 0.32, 0.28);
        vec3 stone2 = vec3(0.45, 0.42, 0.38);
        return mix(stone1, stone2, pattern);
    }
    else if (matId == MAT_HOUSE_WALL) {
        /* Half-timbered look */
        vec3 plaster = vec3(0.9, 0.85, 0.75);
        vec3 timber = vec3(0.3, 0.2, 0.1);
        float beams = step(0.9, abs(sin(p.x * 2.0))) + step(0.9, abs(sin(p.y * 3.0)));
        return mix(plaster, timber, min(beams, 1.0));
    }
    else if (matId == MAT_ROOF) {
        return vec3(0.5, 0.25, 0.15); /* Terracotta tiles */
    }
    else if (matId == MAT_STONE) {
        /* Gray stone with variation */
        float noise = sin(p.x * 5.0) * sin(p.y * 5.0) * sin(p.z * 5.0);
        return vec3(0.5, 0.5, 0.52) + noise * 0.05;
    }
    else if (matId == MAT_WOOD) {
        return vec3(0.4, 0.25, 0.1);
    }
    else if (matId == MAT_FOLIAGE) {
        /* Green foliage with variation */
        float var = sin(p.x * 10.0 + p.y * 5.0) * 0.1;
        return vec3(0.15 + var, 0.4 + var, 0.1);
    }

    return vec3(0.5); /* Default gray */
}

vec3 shade(vec3 p, vec3 rd, vec3 n, int matId) {
    /* Sun direction (afternoon sun) */
    vec3 sunDir = normalize(vec3(0.6, 0.8, 0.3));
    vec3 sunCol = vec3(1.0, 0.95, 0.8);

    /* Sky color for ambient */
    vec3 skyCol = vec3(0.4, 0.5, 0.7);

    /* Material color */
    vec3 matCol = getMaterialColor(matId, p);

    /* Diffuse lighting */
    float diff = max(dot(n, sunDir), 0.0);

    /* Soft shadows */
    float shadow = softShadow(p + n * 0.01, sunDir, 0.02, 30.0, 8.0);

    /* Ambient occlusion */
    float ao = calcAO(p, n);

    /* Sky ambient (hemisphere) */
    float sky = 0.5 + 0.5 * n.y;

    /* Specular (subtle) */
    vec3 h = normalize(sunDir - rd);
    float spec = pow(max(dot(n, h), 0.0), 16.0) * 0.2;

    /* Combine lighting */
    vec3 col = matCol * sunCol * diff * shadow;       /* Direct sun */
    col += matCol * skyCol * sky * ao * 0.3;          /* Sky ambient */
    col += vec3(0.15, 0.12, 0.1) * ao * 0.2;          /* Ground bounce */
    col += spec * shadow;                              /* Specular */

    /* Atmospheric fog (blue-ish distance fog) */
    float fogDist = length(p - vec3(cam_x, cam_y, cam_z));
    float fog = 1.0 - exp(-fogDist * 0.015);
    vec3 fogCol = mix(vec3(0.6, 0.7, 0.85), vec3(0.5, 0.6, 0.8), clamp(rd.y, 0.0, 1.0));
    col = mix(col, fogCol, fog);

    return col;
}

uint packColor(vec3 col) {
    col = clamp(col, 0.0, 1.0);
    col = pow(col, vec3(1.0 / 2.2)); /* Gamma correction */
    uint r = uint(col.r * 255.0);
    uint g = uint(col.g * 255.0);
    uint b = uint(col.b * 255.0);
    return (0xFF000000u) | (r << 16) | (g << 8) | b;
}

/* ============================================================================
 * Main
 * ============================================================================ */

void main() {
    uvec2 pixel = gl_GlobalInvocationID.xy;

    if (pixel.x >= width || pixel.y >= height) return;

    vec2 uv = (vec2(pixel) - 0.5 * vec2(width, height)) / float(height);
    uv.y = -uv.y;  /* Flip Y - buffer origin is top-left */

    /* Camera setup */
    float cy = cos(cam_yaw), sy = sin(cam_yaw);
    float cp = cos(cam_pitch), sp = sin(cam_pitch);

    mat3 camRot = mat3(
        cy, 0, -sy,
        sy * sp, cp, cy * sp,
        sy * cp, -sp, cy * cp
    );

    vec3 rd = camRot * normalize(vec3(uv, -1.0));
    vec3 ro = vec3(cam_x, cam_y, cam_z);

    /* Ray march */
    float dist = rayMarch(ro, rd);

    vec3 col;
    if (dist < MAX_DIST) {
        vec3 p = ro + rd * dist;
        vec3 n = calcNormal(p);

        /* Re-evaluate to get material ID */
        sceneSDF(p);
        col = shade(p, rd, n, g_matId);
    } else {
        /* Sky */
        float t = 0.5 * (rd.y + 1.0);
        vec3 skyBottom = vec3(0.6, 0.7, 0.85);
        vec3 skyTop = vec3(0.3, 0.5, 0.85);
        col = mix(skyBottom, skyTop, t);

        /* Sun glow */
        vec3 sunDir = normalize(vec3(0.6, 0.4, 0.3));
        float sun = pow(max(dot(rd, sunDir), 0.0), 32.0);
        col += vec3(1.0, 0.9, 0.7) * sun * 0.5;
    }

    uint idx = pixel.y * width + pixel.x;
    pixels[idx] = packColor(col);
}
