#version 450

/*
 * SDF Ray Marcher Compute Shader
 *
 * Renders signed distance field scenes using ray marching on the GPU.
 * Designed for real-time visualization at 60+ FPS at 4K resolution.
 *
 * Bindings:
 *   binding 0: output image (rgba8)
 *
 * Push Constants:
 *   camera_pos (vec3): Camera position in world space
 *   camera_yaw (float): Camera horizontal rotation
 *   camera_pitch (float): Camera vertical rotation
 *   time (float): Animation time
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D outputImage;

/* Push constants for fast-changing uniforms */
layout(push_constant) uniform PushConstants {
    vec3 camera_pos;
    float camera_yaw;
    float camera_pitch;
    float time;
    float _padding[2];
} pc;

/* Ray marching parameters */
const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float SURF_DIST = 0.001;
const float PI = 3.14159265359;

/* ============================================================================
 * SDF Primitives
 * ============================================================================ */

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdPlane(vec3 p, vec3 n, float h) {
    return dot(p, n) + h;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}

/* ============================================================================
 * Boolean Operations
 * ============================================================================ */

float opUnion(float d1, float d2) {
    return min(d1, d2);
}

float opSubtraction(float d1, float d2) {
    return max(-d1, d2);
}

float opIntersection(float d1, float d2) {
    return max(d1, d2);
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return mix(d2, -d1, h) + k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

/* ============================================================================
 * Scene Definition
 * ============================================================================ */

float sceneSDF(vec3 p) {
    /* Ground plane */
    float ground = sdPlane(p, vec3(0.0, 1.0, 0.0), 0.0);

    /* Animated sphere */
    float sphere = sdSphere(p - vec3(0.0, 1.0 + 0.3 * sin(pc.time * 2.0), 0.0), 1.0);

    /* Box to the right */
    vec3 boxPos = p - vec3(3.0, 0.75, 0.0);
    float box = sdBox(boxPos, vec3(0.75));

    /* Torus to the left */
    vec3 torusPos = p - vec3(-3.0, 1.0, 0.0);
    /* Rotate torus over time */
    float c = cos(pc.time * 0.5);
    float s = sin(pc.time * 0.5);
    torusPos.xy = mat2(c, -s, s, c) * torusPos.xy;
    float torus = sdTorus(torusPos, vec2(0.8, 0.25));

    /* Cylinder in back */
    float cylinder = sdCylinder(p - vec3(0.0, 1.0, -4.0), 1.0, 0.5);

    /* Blend sphere and box */
    float blended = opSmoothUnion(sphere, box, 0.5);

    /* Combine all */
    float scene = opUnion(ground, blended);
    scene = opUnion(scene, torus);
    scene = opUnion(scene, cylinder);

    return scene;
}

/* ============================================================================
 * Rendering Functions
 * ============================================================================ */

vec3 calcNormal(vec3 p) {
    const float eps = 0.0001;
    vec2 e = vec2(1.0, -1.0) * 0.5773 * eps;
    return normalize(
        e.xyy * sceneSDF(p + e.xyy) +
        e.yyx * sceneSDF(p + e.yyx) +
        e.yxy * sceneSDF(p + e.yxy) +
        e.xxx * sceneSDF(p + e.xxx)
    );
}

float rayMarch(vec3 ro, vec3 rd, out int steps) {
    float depth = 0.0;
    steps = 0;

    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * depth;
        float d = sceneSDF(p);
        steps = i;

        if (d < SURF_DIST) break;
        if (depth > MAX_DIST) break;

        depth += d;
    }

    return depth;
}

float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float t = mint;

    for (int i = 0; i < 64 && t < maxt; i++) {
        float h = sceneSDF(ro + rd * t);
        if (h < 0.001) return 0.0;
        res = min(res, k * h / t);
        t += h;
    }

    return res;
}

float ambientOcclusion(vec3 p, vec3 n) {
    float occ = 0.0;
    float sca = 1.0;

    for (int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = sceneSDF(p + h * n);
        occ += (h - d) * sca;
        sca *= 0.95;
    }

    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

vec3 shade(vec3 p, vec3 rd, vec3 n, int steps) {
    /* Light direction */
    vec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));
    vec3 lightCol = vec3(1.0, 0.95, 0.9);

    /* Material color based on position */
    vec3 matCol;
    if (p.y < 0.01) {
        /* Ground - checkerboard */
        float check = mod(floor(p.x) + floor(p.z), 2.0);
        matCol = mix(vec3(0.1, 0.3, 0.1), vec3(0.2, 0.5, 0.2), check);
    } else {
        /* Objects - gradient based on height */
        matCol = mix(vec3(0.8, 0.3, 0.2), vec3(0.2, 0.3, 0.8), p.y * 0.3);
    }

    /* Diffuse lighting */
    float diff = max(dot(n, lightDir), 0.0);

    /* Specular */
    vec3 h = normalize(lightDir - rd);
    float spec = pow(max(dot(n, h), 0.0), 32.0);

    /* Shadows */
    float shadow = softShadow(p + n * 0.01, lightDir, 0.01, 10.0, 16.0);

    /* Ambient occlusion */
    float ao = ambientOcclusion(p, n);

    /* Ambient */
    vec3 ambient = vec3(0.1, 0.12, 0.15) * ao;

    /* Combine */
    vec3 col = ambient;
    col += matCol * lightCol * diff * shadow;
    col += vec3(0.3) * spec * shadow;

    /* Fog */
    float fogDist = length(p - pc.camera_pos);
    float fog = 1.0 - exp(-fogDist * 0.03);
    col = mix(col, vec3(0.5, 0.6, 0.7), fog);

    return col;
}

/* ============================================================================
 * Main
 * ============================================================================ */

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);

    /* Bounds check */
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    /* Calculate UV coordinates */
    vec2 uv = (vec2(pixel) - 0.5 * vec2(size)) / float(size.y);

    /* Camera setup */
    float yaw = pc.camera_yaw;
    float pitch = pc.camera_pitch;

    /* Camera rotation matrix */
    float cy = cos(yaw), sy = sin(yaw);
    float cp = cos(pitch), sp = sin(pitch);

    mat3 camRot = mat3(
        cy, 0, -sy,
        sy * sp, cp, cy * sp,
        sy * cp, -sp, cy * cp
    );

    /* Ray direction */
    vec3 rd = camRot * normalize(vec3(uv, -1.0));
    vec3 ro = pc.camera_pos;

    /* Ray march */
    int steps;
    float dist = rayMarch(ro, rd, steps);

    /* Shading */
    vec3 col;
    if (dist < MAX_DIST) {
        vec3 p = ro + rd * dist;
        vec3 n = calcNormal(p);
        col = shade(p, rd, n, steps);
    } else {
        /* Sky gradient */
        float t = 0.5 * (rd.y + 1.0);
        col = mix(vec3(0.5, 0.6, 0.7), vec3(0.2, 0.4, 0.8), t);
    }

    /* Gamma correction */
    col = pow(col, vec3(1.0 / 2.2));

    /* Output */
    imageStore(outputImage, pixel, vec4(col, 1.0));
}
