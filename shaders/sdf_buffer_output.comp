#version 450

/*
 * SDF Ray Marcher Compute Shader (Buffer Output)
 *
 * Outputs to a buffer for compatibility with simple_vulkan's
 * current buffer-based binding. Each pixel is stored as RGBA8
 * packed into a uint32.
 *
 * Bindings:
 *   binding 0: output buffer (uint array, RGBA packed)
 *   binding 1: uniform buffer (camera params)
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* Output buffer - each uint is one RGBA pixel */
layout(std430, binding = 0) buffer OutputBuffer {
    uint pixels[];
};

/* Camera parameters */
layout(std430, binding = 1) buffer CameraParams {
    float cam_x;
    float cam_y;
    float cam_z;
    float cam_yaw;
    float cam_pitch;
    float time;
    uint width;
    uint height;
};

/* Ray marching parameters */
const int MAX_STEPS = 64;
const float MAX_DIST = 50.0;
const float SURF_DIST = 0.002;
const float PI = 3.14159265359;

/* ============================================================================
 * SDF Primitives
 * ============================================================================ */

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdPlane(vec3 p, vec3 n, float h) {
    return dot(p, n) + h;
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

/* ============================================================================
 * Boolean Operations
 * ============================================================================ */

float opUnion(float d1, float d2) {
    return min(d1, d2);
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

/* ============================================================================
 * Scene Definition
 * ============================================================================ */

float sceneSDF(vec3 p) {
    /* Ground plane */
    float ground = sdPlane(p, vec3(0.0, 1.0, 0.0), 0.0);

    /* Animated sphere */
    float sphere = sdSphere(p - vec3(0.0, 1.0 + 0.3 * sin(time * 2.0), 0.0), 1.0);

    /* Box to the right */
    float box = sdBox(p - vec3(3.0, 0.75, 0.0), vec3(0.75));

    /* Torus to the left */
    vec3 torusPos = p - vec3(-3.0, 1.0, 0.0);
    float c = cos(time * 0.5);
    float s = sin(time * 0.5);
    torusPos.xy = mat2(c, -s, s, c) * torusPos.xy;
    float torus = sdTorus(torusPos, vec2(0.8, 0.25));

    /* Blend sphere and box */
    float blended = opSmoothUnion(sphere, box, 0.5);

    /* Combine all */
    float scene = opUnion(ground, blended);
    scene = opUnion(scene, torus);

    return scene;
}

/* ============================================================================
 * Rendering
 * ============================================================================ */

vec3 calcNormal(vec3 p) {
    const float eps = 0.001;
    vec2 e = vec2(1.0, -1.0) * 0.5773 * eps;
    return normalize(
        e.xyy * sceneSDF(p + e.xyy) +
        e.yyx * sceneSDF(p + e.yyx) +
        e.yxy * sceneSDF(p + e.yxy) +
        e.xxx * sceneSDF(p + e.xxx)
    );
}

float rayMarch(vec3 ro, vec3 rd) {
    float depth = 0.0;

    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * depth;
        float d = sceneSDF(p);

        if (d < SURF_DIST) break;
        if (depth > MAX_DIST) break;

        depth += d;
    }

    return depth;
}

vec3 shade(vec3 p, vec3 rd, vec3 n) {
    vec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));

    /* Material color */
    vec3 matCol;
    if (p.y < 0.01) {
        /* Ground - checkerboard */
        float check = mod(floor(p.x) + floor(p.z), 2.0);
        matCol = mix(vec3(0.1, 0.3, 0.1), vec3(0.2, 0.5, 0.2), check);
    } else {
        /* Objects */
        matCol = mix(vec3(0.8, 0.3, 0.2), vec3(0.2, 0.3, 0.8), p.y * 0.3);
    }

    /* Diffuse */
    float diff = max(dot(n, lightDir), 0.0);

    /* Specular */
    vec3 h = normalize(lightDir - rd);
    float spec = pow(max(dot(n, h), 0.0), 32.0);

    /* Ambient */
    vec3 ambient = vec3(0.15, 0.17, 0.2);

    /* Combine */
    vec3 col = ambient * matCol;
    col += matCol * diff * 0.8;
    col += vec3(0.3) * spec * 0.5;

    /* Simple fog */
    float fogDist = length(p - vec3(cam_x, cam_y, cam_z));
    float fog = 1.0 - exp(-fogDist * 0.05);
    col = mix(col, vec3(0.5, 0.6, 0.7), fog);

    return col;
}

/* Pack RGB to uint (ARGB format) */
uint packColor(vec3 col) {
    col = clamp(col, 0.0, 1.0);
    /* Gamma correction */
    col = pow(col, vec3(1.0 / 2.2));
    uint r = uint(col.r * 255.0);
    uint g = uint(col.g * 255.0);
    uint b = uint(col.b * 255.0);
    return (0xFF000000u) | (r << 16) | (g << 8) | b;
}

/* ============================================================================
 * Main
 * ============================================================================ */

void main() {
    uvec2 pixel = gl_GlobalInvocationID.xy;

    /* Bounds check */
    if (pixel.x >= width || pixel.y >= height) return;

    /* Calculate UV coordinates */
    vec2 uv = (vec2(pixel) - 0.5 * vec2(width, height)) / float(height);

    /* Camera setup */
    float cy = cos(cam_yaw), sy = sin(cam_yaw);
    float cp = cos(cam_pitch), sp = sin(cam_pitch);

    mat3 camRot = mat3(
        cy, 0, -sy,
        sy * sp, cp, cy * sp,
        sy * cp, -sp, cy * cp
    );

    /* Ray direction */
    vec3 rd = camRot * normalize(vec3(uv, -1.0));
    vec3 ro = vec3(cam_x, cam_y, cam_z);

    /* Ray march */
    float dist = rayMarch(ro, rd);

    /* Shading */
    vec3 col;
    if (dist < MAX_DIST) {
        vec3 p = ro + rd * dist;
        vec3 n = calcNormal(p);
        col = shade(p, rd, n);
    } else {
        /* Sky gradient */
        float t = 0.5 * (rd.y + 1.0);
        col = mix(vec3(0.5, 0.6, 0.7), vec3(0.2, 0.4, 0.8), t);
    }

    /* Output pixel */
    uint idx = pixel.y * width + pixel.x;
    pixels[idx] = packColor(col);
}
